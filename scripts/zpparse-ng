#!/usr/bin/env python2

import sys, os, string
import urllib
from lxml import etree
from zpbuild_globals_ng import build_targets, python_targets, zpconf, zpdef_file, reldef_file, builddefs
import codecs
import json

zp_json = None
rel_json = None
zp_pydict = {}
rel_pydict = {}

zpdef_url="http://127.0.0.1/Special:Ask/-5B-5BCategory:ZenPacks-5D-5D-20-5B-5BFlavor::free-5D-5D/-3F-23-2D/-3FOrganization/-3FAuthor/-3FMaintainer/-3FSummary/-3FCategories/-3FSource-20URI/-3FLicense/format%3Djson/limit%3D99999/offset%3D0"

reldef_url="http://127.0.0.1/Special:Ask/-5B-5BRelease-20of::%2B-5D-5D/-3FRelease-20of%3DZenPack/-3FVersion/-3FTag/-3FCompatible-20with/-3FIncompatible-20with/--3FRequires/format%3Djson/limit%3D99999/mainlabel%3D-2D/offset%3D0"

def updateDefs(url, outfile):
	""" given a URL, read JSON and write it out to a file on disk."""
	# Update ZenPack definition JSON file from wiki, update our internal xmlroot variable with new data as well.
	req = urllib.urlopen(url)
	encoding=req.headers['content-type'].split('charset=')[-1]
	ucontent=unicode(req.read(),encoding)
	l = open(outfile, 'w')
	l.write(ucontent.encode('utf-8'))
	req.close()
	l.close()

def parseDefs(json_fn, altkeys=None):
	"""Given a filename, read JSON in, and parse it from Semantic Mediawiki output format into a much simpler nested dictionary format.
	
	Optional value alkeys allows you to specify property names to index properties rather than the default.
	altkeys=["ZenPack", "Version" ] would cause dict to be nested by ZenPack and Version, allowing multiple
	instances of ZenPacks in the data as long as they had separate versions:

	simpledict = { "ZenPack Foo" : { "1.2" : { properties },  "1.3" : { properties }} }

	"""
	l = codecs.open(json_fn, 'r', 'utf-8')
	my_json = json.load(l)
	l.close()
	simple_dict = {}
	# key will be the name of each object exported in the JSON:
	for key in my_json["results"]:
		# props will store all the property key/value pairs for the object we are processing:
		props = {}
		# elkey contains the property key name:
		for elkey in my_json["results"][key]["printouts"]:
			# blob can be a list of dicts, or strings. Handle carefully to get property values: 
			blob = my_json["results"][key]["printouts"][elkey]
			# update our simple dictionary with the property and value, or None
			# outval will be the value we write to simple_dict[key][elkey]:
			if not len(blob):
				# blob is empty, property value was not defined:
				outval = None
			elif type(blob[0]) == type({}):
				# blob contains dicts, grab "fulltext" from each dict, add to list:
				outval = []
				for d in blob:
					outval.append(d["fulltext"])
			else:
				# we will assume that we have strings or numbers, so just append them directly:
				outval = blob
			# if things are in lists, but only have one item, remove the outer list. Otherwise preserve it:
			# (This happens when we have multi-select, like when you can specify multiple authors, but specify only one...)
			if type(outval) == type([]) and len(outval) == 1:
				outval = outval[0]
			props[elkey] = outval
		# a heirarchy of keys has been specified, which we will use to grab a value to use as an index for a dict (this is a feature
		# to get the ZenPack version and use it as a key in our dict...)
		orig_key = key 
		if altkeys:
			# ix will reference the current dict to dump our properties in...
			ix = simple_dict 
			for i in range(0,len(altkeys)):
				a = altkeys[i]
				# heirarchically create keys
				if a in props:
					key = props[a]
				else:
					# this shouldn't happen - we can't find one of the keys we're looking for...
					raise IndexError
				if i == len(altkeys) - 1:
					# end - do assignment
					if type(key) == type([]):
						# our key index is a *list* -- this should not happen but appears to happen when there is a ZenPack
						# that doesn't have an approved version of the page. It's wacky..
						print("%s may need to be approved via ApprovedRevs on mediawiki. We are getting bogus semantic data for a release." % orig_key)
						print ("key is %s" % key)
						print ("altkeys is %s" % altkeys)
						print ("orig key is %s" % orig_key)
						raise IndexError
					ix[key] = props
				else:
					# move ix deeper...
					if key not in ix:
						ix[key] = {}
					ix = ix[key]
		else:
			simple_dict[key] = props
	# the output format is simple_dict["MyObject"]["myproperty"] = myvalue.
	# myvalue can be None, if not specified, a single value, like a string, or a list of things, like a list of strings, if multiple values were specified.
	return simple_dict

if __name__ == "__main__":
	#sys.stderr.write("Updating JSON ZenPack definitions...\n")
	updateDefs(zpdef_url, zpdef_file)
	zpdefs = parseDefs(zpdef_file)
	updateDefs(reldef_url, reldef_file)
	reldefs = parseDefs(reldef_file, altkeys=[ "ZenPack", "Version" ])
	for x in zpdefs:
		if x in reldefs:
			zpdefs[x]["Releases"] = reldefs[x]
	a = open(builddefs, 'w')
	json.dump(zpdefs, a, sort_keys=True, indent=4, separators=(',',': '))
	a.close()
	#sys.stderr.write("Done.\n")

